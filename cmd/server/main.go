package main

import (
	"context"
	"flag"
	"log/slog"
	"net/http"

	"github.com/modelcontextprotocol/go-sdk/mcp"

	"suse-observability-mcp/client/suseobservability"
	"suse-observability-mcp/internal/tools"
)

func main() {
	// SUSE Observability flags
	url := flag.String("url", "", "SUSE Observability API URL")
	token := flag.String("token", "", "SUSE Observability API Token")
	useAPIToken := flag.Bool("apitoken", false, "Indicates if the token is an API token, instead of a service token")

	// MCP server flags
	listenAddr := flag.String("http", "", "address for http transport, defaults to stdio")
	flag.Parse()

	client, err := suseobservability.NewClient(*url, *token, *useAPIToken)
	if err != nil {
		return
	}

	mcpTools := tools.NewBaseTool(client)

	mcpServer := mcp.NewServer(&mcp.Implementation{Name: "SUSE Observability MCP server", Version: "v0.0.1"}, nil)

	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "listMetrics",
		Description: `Fetches available metrics from SUSE Observability.
		Returns:
		The JSON representation of available metrics from SUSE Observability`},
		mcpTools.ListMetrics,
	)
	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "queryMetric",
		Description: `Query metrics from SUSE Observability.
		Returns:
		The JSON representation of the query result from SUSE Observability`},
		mcpTools.QueryMetric,
	)
	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "queryRangeMetric",
		Description: `Query metrics from SUSE Observability over a range of time.
		Returns:
		The JSON representation of the query result from SUSE Observability`},
		mcpTools.QueryRangeMetric,
	)
	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "queryTopology",
		Description: `Query topology from SUSE Observability.
		Returns:
		The JSON representation of the topology query result from SUSE Observability`},
		mcpTools.QueryTopology,
	)
	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "listMonitors",
		Description: `List all available monitors in SUSE Observability.
		Returns:
		The JSON representation of all monitors`},
		mcpTools.ListMonitors,
	)
	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "getMonitorDetails",
		Description: `Get detailed information about a specific monitor.
		Returns:
		The JSON representation of the monitor`},
		mcpTools.GetMonitorDetails,
	)
	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "getMonitorCheckStates",
		Description: `Get check states generated by a monitor.
		Use this to see what components are failing or in a specific state for a monitor.
		Returns:
		The JSON representation of the check states`},
		mcpTools.GetMonitorCheckStates,
	)
	mcp.AddTool(mcpServer, &mcp.Tool{
		Name: "getMonitorCheckStatus",
		Description: `Get detailed check status information for a specific check state.
		Use this to investigate the root cause of a monitor failure.
		Returns:
		The JSON representation of the check status including metrics and component info`},
		mcpTools.GetMonitorCheckStatus,
	)

	if *listenAddr == "" {
		// Run the server on the stdio transport.
		if err := mcpServer.Run(context.Background(), &mcp.StdioTransport{}); err != nil {
			slog.Error("Server failed", "error", err)
		}
	} else {
		// Create a streamable HTTP handler.
		handler := mcp.NewStreamableHTTPHandler(func(*http.Request) *mcp.Server {
			return mcpServer
		}, nil)

		// Run the server on the HTTP transport.
		slog.Info("Server listening", "address", *listenAddr)
		if err := http.ListenAndServe(*listenAddr, handler); err != nil {
			slog.Error("Server failed", "error", err)
		}
	}
}
